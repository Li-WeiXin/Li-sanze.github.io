---
title: Monorepo演进
date: 2025-01-23
categories:
 - design
tags:
 - design
sidebar: 'auto'
---

# 1. 什么是Monorepo

Monorepo是一种项目代码管理方式，指单个仓库中管理多个项目，有助于简化代码共享、版本控制、构建和部署等方面的复杂性，并提供更好的复用性与协作性。

Monorepo提倡开放、透明、共享的组织文化，这种方法已经被很多大型互联网公司广泛使用，如`Google`、`Facebook`和`Microsoft`等。

`mono`来源于希腊语 μόνος ，意味单个的；`repo`是 repository 的缩写，将不同的项⽬的代码放在同⼀个代码仓库中，这种把鸡蛋放在同⼀个篮子的做法乍看之下有些奇怪。但实际上，这种管理模式有如下好处：

**单一的仓库：**&#x5C06;多个项目（子包）集中在同一个项目中进行管理，减少版本冲突。

**统一管理依赖：**&#x901A;过工具（如PNPM、Lerna、Turborepo等）实现依赖统一安装和版本管理。

**共享代码：**&#x901A;过空间或内部包机制共享公共模块。

**统一构建和发布：**&#x53EF;以对多个子包进行一次性构建和发布。

> 前端开发中使用的Vue、React、QianKun都是在Monorepo策略仓库中开发出来的。

一个真正的Monorepo不仅仅是将多个项目的代码放在同一个代码库中。它还需要这些项目之间有明确定义的关系。如果这些项目之间没有良好定义的关系，那么就不能称之为Monorepo，项目之间应该具有良好的结构和模块化。

# 2. Repository项目管理发展历程

从单仓库巨石应用（Monolith），到多仓库多模块应用（Multirepo），最后转向单仓库多模块应用（Monorepo），每个阶段都有其优势和挑战。选择哪种方式取决于项目的具体需求和团队的工作流程。

## 2.1 单仓库巨石应用（Monolith）

这种结构在项目初期比较常见，由于一切都在一个仓库里，所以便于管理和部署。但随着项目的迭代，这种结构的缺点逐渐显现，包括但不限于构建时间的增长，代码冲突的频繁、以及难以维护。

## 2.2 多仓库多应用（Multirepo）

为了克服巨⽯应⽤的缺点，项⽬可能被拆分成多个较⼩的模块，每个模块使⽤单独的仓库管理。这样做可以提⾼模块的独⽴性，便于团队并⾏开发 和维护，但也带来了新的挑战，比如跨仓库的依赖管理、版本同步问题以及工作流程的复杂性的增加。

## 2.3 单仓库多应用（Monorepo ）

为了解决多仓库管理带来的问题，有些团队和项⽬转向使⽤单仓库来管理多个模块。这种⽅式可以简化跨模块的依赖管理，提⾼代码共享的效率，并且可以统⼀构建和测试流程。不过，Monorepo也有其挑战，比如需要更精细的权限控制、针对大规模仓库的性能优化等。

**总结：**&#x6BCF;种⽅法都有其适⽤场景，没有绝对的好坏。例如，⼩到中型项⽬可能会更倾向于使⽤ Monolith 或MultiRepo，⽽⼤型项⽬和⼤型团队可能会从 MonoRepo中获益，尤其是当需要 频繁地跨模块协作时。在选择最适合⾃⼰项⽬的策略时，需要权衡各种因素，包括团队规模、 项⽬复杂度、构建和测试流程的需求等。

Repository项目管理演进

⼀个真正的 Monorepo 不仅仅是将多个项⽬的代码放在同⼀个代码库中。它还需要这些项⽬之间有明确定义的关系。如果这些项⽬之间没有良好定义的关系，那么就不能称之为Monorepo。

类似地，如果⼀个代码库中包含了⼀个庞⼤的应⽤，⽽没有对其进⾏分割和封装，那么这只是⼀个⼤型的代码库，而不是真正的Monorepo。

Monorepo 中的各个项⽬（或模块、组件）之间应该有清晰、明确的依赖关系。这有助于确保模块间可以高效协作，同时保持一定程度的独立性和可重用性。

# 3. Monorepo 优劣

| 场景    | Multirepo                                                                                                                                                                                                                                                       | Monorepo                                                                                                                                                                                                                                                                                   |
| ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 代码可⻅性 | ✅由于项⽬被分散在不同的仓库中，可以对每个仓库实施独⽴的访问控制，这有助于保护敏感代码，减少安全风险。❌由于代码分散在多个仓库中，重⽤通⽤代码或库变得更加困难。开发⼈员可能需要复制代码到他们的仓库中，这会导致重复工作和加重维护难度。                                                                                                                                            | ✅所有代码都在⼀个仓库中，使 得代码的共享和重⽤变得⾮常⽅便。开发⼈员可以轻松访问和使⽤公共库和⼯具。❌虽然可以通过精细的权限控制限制对特定代码部分的访问，但在⼤型MonoRepo中管理这些权限会变得复杂&耗时。                                                                                                                                                                                 |
| 依赖管理  | ✅ 每个项⽬可以独⽴管理⾃⼰的依赖版本，这有助于避免因共享依赖导致的版本冲突问题。 ❌ 多个项⽬可能会依赖同⼀库的不同版本，这可能导致重复的配置⼯作和维护成本。❌当共享的库需要更新时，各个 项⽬需要分别进⾏更新，这可能导致同步和⼀致性问题。❌如果项⽬间存在依赖，管理依赖项会变得复杂。                                                                                                                  | ✅ 所有项⽬共享相同的依赖库版 本，这简化了依赖管理，减少了版本冲突的可能性。✅ 当共享库需要更新时，整个仓库中的所有项⽬可以同时更新，确保了依赖的⼀致性。✅ 由于所有项⽬使⽤相同的依赖版本，当发现某个依赖的问题时，可以快速地识别出所有受影响的项⽬并进⾏修复。❌所有项⽬必须使⽤相同版本的依赖，这可能限制了某些项⽬使⽤特定版本的能⼒，特别是当某些项⽬需要使用较新或较久版本时候。                                                                                              |
| 开发迭代  | ✅ 在多仓库模式下，每个仓库可以独⽴进⾏迭代，不受其他项⽬进度的影响。这意味着团队可以根据每个项⽬的需求和优先级安排迭代计划。✅ 由于每个项⽬独⽴管理，团队可以为每个项⽬选择最适合的技术栈、⼯具和流程，提⾼了迭代过程的灵活性。❌当需要在多个项⽬之间进⾏协 作或共享代码时，跨仓库的协作可能会增加沟通和整合的成本。❌在多仓库模式下，跨项⽬的依 赖管理可能会变得复杂，需要额外的努⼒来确保依赖项的⼀致性和兼容性，加大工作量。                                              | ✅ 所有项⽬和模块共享同⼀个仓库，使得团队可以采⽤统⼀的⼯作流程、构建和测试⼯具，简化了迭代过程。✅ 当共享库需要更新时，整个仓 库中的所有项⽬可以同时更新，确保了依赖的⼀致性。❌ 在 MonoRepo 中，所有项⽬共享同⼀个版本历史，这可能会导致版本控制⽇志变得杂乱⽆ 章，使得追踪特定项⽬的更改变得更加困难。❌对于⾮常⼤的仓库，构建和测试的速度可能会成为问题，尤其是当不需要构建整个仓库的所有部分时。虽然有策略如增量构建和缓存可以缓解这个问题，但需要额外的配置和维护⼯作。                                             |
| ⼯程配置  | ✅ 每个仓库可以有其独⽴的构建、测试和部署配置，这允许项 ⽬根据⾃⼰的特定需求定制化⼯ 程配置，提供了⾼度的灵活性。 ✅ 相对于 MonoRepo，单个项⽬的配置通常更简单、更直接， 因为它只需要关注⾃⾝的需求，⽽不是必须考虑到与其他项⽬的协作和兼容性。❌随着仓库数量的增加，重复的配置和⼯具链设置可能导致维护成本增加。每个项⽬可能需要单独维护构建脚本、依赖管理⽂件、CI/CD 配置等。❌在多仓库环境中，不同项⽬之间的配置可能会出现不⼀致，导致构建、测试和部署流程的差 异，增加了团队成员之间协作的 复杂性。 | ✅ 所有项⽬共享同⼀个构建系统 和⼯具链，这有助于确保整个代码库的⼀致性和可维护性，简化了⼯程配置的管理。✅ 具和依赖库的版本可以在整个 仓库中统⼀管理，减少了版本冲突的可能性，并确保所有项⽬都使⽤了正确的⼯具和库版本。❌ 由于所有项⽬使⽤相同的依赖版本，当发现某个依赖的问题时，可以快速地识别出所有受影响的项⽬并进⾏修复。随着项⽬数量和类型的增加，MonoRepo的配置可能变得复杂，需要更复杂的⼯具和脚本来⽀持不同类型的项⽬和构建流程。❌ 对于⼤型 MonoRepo，构建和测试整个仓库可能⾮常耗时，尽管可以通过一些优化技术（如增量构建和缓存）来缓解这⼀问题。 |
| 构建部署  | ✅ 每个仓库可以独⽴构建和部署，这允许项⽬团队按照⾃⼰的时间表和需求来更新服务，提⾼了部署的灵活性。✅ 项⽬之间的隔离性减少了构建和部署过程中的相互影响，⼀个项⽬的更改不会直接影响到其他项⽬的构建或稳定性。❌在多仓库结构中，相似的构建和部署流程可能需要在多个项⽬中重复配置，导致维护成本和⼯作量增加。❌当项⽬之间存在依赖关系时， 协调和同步不同仓库的构建和部署变得更加复杂，尤其是在进⾏ ⼤规模更新时。                                                       | ✅ 所有项⽬共享同⼀个构建系统，这有助于简化和标准化构建流程，提⾼效率。✅ 在 MonoRepo 中，涉及多个项⽬的更改可以在⼀个提交中完 成，这简化了回滚和跟踪更改的过程，提⾼了部署的可靠性。✅ 由于所有代码都在同⼀个仓库 中，管理和升级跨项⽬依赖变得更加容易，有助于确保依赖的⼀致性。❌ MonoRepo 可能限制了部署粒度，因为所有项⽬共享相同的构建和部署流程。这可能导致即使只需部署⼀个⼩改动，也可能需要重新构建和部署整个代码库 中的多个项⽬。                                                         |

# 4. Monorepo的使用场景

Monorepo（单仓库）模式适⽤于多种场景，特别是在以下情况下，使⽤ Monorepo 可以带来显著的好处：

1. **团队协作：** 当⼤型团队在多个相关项⽬上协作时，Monorepo 可以简化协作流程。由于所有项⽬都位于同⼀仓库中，团队成员可以轻松访问和修改跨项⽬的代码，促进了团队间的沟通和合作。

2. **微服务架构：** 在微服务架构中，系统由多个⼩型、独⽴服务组成。使⽤ Monorepo 可以⽅便地管理这些服务的代码，通过将多个前端项目整合为一个Monorepo，来确保服务之间的兼容性，并简化跨服务的重构和共享代码。

3. **多平台 / 多产品/模块开发：**&#x5BF9;于跨多个平台（如 Web、iOS、Android）或多个产品线开发的公司，Monorepo 可以提供⼀个统⼀的代码基础，使得共享通⽤库、组件和⼯具变得简单，同时保持构建和发布流程的⼀致性。

4. **共享库和组件：**&#x5728;开发涉及多个共享库或可重⽤组件的项⽬时，Monorepo 允许开发⼈员轻松更新和维护这些共享资源。这有助于提⾼代码重⽤率，降低维护成本。

5. **统⼀的⼯具和流程：** 对于希望统⼀代码⻛格、构建⼯具、测试框架和部署流程的团队，Monorepo 提供了⼀个共同的基础设施，有助于标准化开发实践，简化新成员的⼊职过程。

6. **原⼦性更改和重构：** 当需要对跨多个项⽬或模块的代码进⾏重构或更新时，Monorepo 使得这些更改可以作为⼀个原⼦提交进⾏，降低了部署和回滚的复杂性。

# 5. pnpm与Monorepo的最佳实践

## 5.1 pnpm简介

> 中文官网：https://www.pnpm.cn/installation

**pnpm优势：**

* 链接机制

* 缓存机制，寻址

* 原生支持workspace

* 磁盘占用少

核⼼亮点：软链接和硬链接，pnpm 使⽤⼀种称为内容寻址存储的⽅法（中心化思想）来保存依赖项。在这种机制下，依赖项的存储位置基于其内容的哈希值，这意味着：

其中⼀个受⼤家⽐较欢迎的就是我们打开 pnpm 官⽹就能直接看到的内容，那就是安装快：

![](https://nio.feishu.cn/space/api/box/stream/download/asynccode/?code=YmYzYmI3YjgwZDM5MmEzMTM3MDM4ZDlmMTU4NTJiZTBfYTBiWlJub3hCbEhJOU01djIydlhOZzlDZG5KRU5mSWNfVG9rZW46UDdpdWJvdWhob3VjeGt4eGVncmM3Ylg1bmxnXzE3NDExNDAzOTI6MTc0MTE0Mzk5Ml9WNA)

pnpm 在安装依赖包时，主要经历了以下三个步骤：解析依赖、获取依赖以及链接依赖。这个 过程通过优化来确保⾼效的依赖管理，尤其在处理⼤型项⽬或 Monorepo 时。

1. &#x20;解析依赖（Dependency Resolution） 在这个阶段，pnpm 需要确定要安装的每个依赖包的具体版本。它会查看项⽬的 package.json ⽂件以及任何现有的锁⽂件（如 pnpm-lock.yaml），来决定哪些版本的包需要被安装。解析依赖时，pnpm 会遵循以下规则：

   * 版本兼容性：基于 package.json 中指定的版本范围，选择与之兼容的最新版本。

   * &#x20;锁⽂件：如果存在锁⽂件，pnpm 会优先使⽤锁⽂件中锁定的版本，以确保依赖的⼀致性和项⽬的可重现性。

2. 获取依赖（Fetching Dependencies） ⼀旦确定了需要安装的依赖版本，pnpm将开始获取这些依赖包。这个过程包括以下⼏个步骤：

   * 检查全局存储：pnpm ⾸先会检查其全局存储中是否已经存在所需版本的依赖包。如果已经存在，就不需要从远程仓库下载，直接重⽤即可。

   * 下载缺失的依赖：对于全局存储中不存在的依赖，pnpm 会从 npm 或其他配置的仓库下载它们。下载的依赖包会被存储在全局存储中，以便复用。

   * &#x20;内容寻址存储：pnpm 使⽤内容寻址⽅式来存储依赖包，即根据包内容的哈希值来确定存储路径。这确保了相同内容的包在全局存储中只有⼀份副本，节省了磁盘空间。

3. 链接依赖（Linking Dependencies） 获取依赖包之后，pnpm 需要将这些依赖链接到项⽬的 node\_modules ⽬录中，使得项⽬能够使⽤这些依赖。这个步骤涉及：

   * 创建硬链接和符号链接：对于每个依赖包，pnpm 会在项⽬的 node\_modules ⽬录中创建指向全局存储中相应包的硬链接。如果是包内部的依赖，还可能创建符号链接来保持正确的依赖结构。

   * pnpm 通过构建⼀个虚拟的 node\_modules ⽬录来模拟传统的嵌套依赖结构，但实际上依赖之间是通过符号链接相连的。这样做既保持了 npm ⽣态的兼容性，⼜避免了重复的依赖副本和深层嵌套的问题。

   * 通过这种链接⽅式，pnpm 确保了项⽬只能访问其直接依赖的包，防⽌了对未声明依赖的意外访问，提⾼了项⽬的稳定性和安全性。

通过上述三个步骤，pnpm 实现了对依赖的⾼效管理，优化了存储空间的使⽤，加快了依赖安装的速度，同时还保证了项⽬依赖的⼀致性和隔离性。

## 5.2 统一配置：合并同类项&#x20;

在 Monorepo 项⽬中统⼀配置 ESLint、TypeScript 可以帮助保持代码的⼀致性，简化项目维护，并提高开发效率。

### Typescript

我们可以在 packages ⽬录中放置 tsconfig.settting.json ⽂件，并在⽂件中定义通⽤的 ts 配置，然后，在每个⼦项⽬中，我们可以通过 extends 属性，引⼊通⽤配置，并设置 compilerOptions.composite的值为true，理想情况下，子项目的tsconfig文件应该包含如下内容：

```json
{
    // 继承 packages ⽬录下通⽤配置
    "extends" : "../../tsconfig.setting.json" ,
    //⽤于帮助 TypeScript 快速确定引⽤⼯程的输出⽂件位置
    "compilerOptions" : { "composite" : true , "outDir" : "dist" , "rootDir" : "src" },
    "include" : [ "src" ]
}
```

### Eslint

对于 eslint，我们可以使⽤相同的思想来实现这⼀规则，在包的.eslint.js文件中，使用extends字段来继承顶层配置，并添加或覆盖规则。

```javascript
module.exports = { 
    extends : "../../.eslintrc.js" ,
    rules : { 
        //重写或添加规则
    },
 }
```

# 6. 传统架构到Monorepo的演进

* **阶段1:&#x20;**&#x4F20;统架构基础痛点（主要矛盾）

  * 代码先集中化，将多个关联项目统一到一个gitlab

  * 工具引入，pnpm workspace

  * CI/CD 重构

* **阶段2:&#x20;**&#x5177;体Monorepo架构

  * 公共模块抽离

  * pnpm、turbo 解决子包与主包关系

* **阶段3:&#x20;**&#x81EA;动化构建流程优化

  * 打包方案：**vite**、webpack、rollup、parcel、**tsup**、esbuild、swc、rolldown&#x20;

  * 构建流程优化，依赖关系（循环依赖引用）、哪些包需要前置依赖/后置依赖

  * 发布，npm publish、docker 镜像

  * 监控和测试

* 关键性的MileStone

  1. 项目统一

  2. pnpm配置

  3. 依赖管理

  4. 统一化脚本

     1. 工程化脚本：package.json中的script

     2. 部署阶段脚本：scripts 文件夹

# 7. 参考文献

[Turborepo 文档](https://turbo.rust-lang.net.cn/repo/docs)

[pnpm中文官网](https://www.pnpm.cn/motivation)
